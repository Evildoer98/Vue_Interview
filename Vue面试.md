# 一、Vue的响应式系统

    Vue为MVVM框架，当数据data发生变化时，页面视图会得到响应更新，其原理是对 data 的getter/setter方法进行拦截（ Object.defineProperty 或者 Proxy ），利用发布订阅的设计模式，在 getter 方法进行订阅，在 setter 方法中发布通知，让所有订阅者完成响应

    在响应式系统中，Vue 会为数据模型 data 的每一个属性新建一个订阅中心作为发布者，而监听器 watch、计算属性 computed、视图渲染 template/render 三个角色同时作为订阅者，对于监听器watch，会直接订阅观察监听的属性，对于计算属性computed和视图渲染template/render，如果内部执行获取了data的某个属性，就会执行该属性的getter方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的setter方法，从而完成该属性的发布通知，通知所有订阅者进行更新。

# 二、computed 与 watch 的区别

 计算属性 computed：
        （1）支持缓存，只有依赖数据发生变化时，才会重新进行计算函数；
        （2）计算属性内不支持异步操作；
        （3）计算属性的函数中都有一个 get(默认具有，获取计算属性)和 set(手动添加，设置计算属性)方法；
        （4）计算属性是自动监听依赖值的变化，从而动态返回内容。
 侦听属性 watch：
        （1）不支持缓存，只要数据发生变化，就会执行侦听函数；
        （2）侦听属性内支持异步操作；
        （3）侦听属性的值可以是一个对象，接收 handler 回调，deep，immediate 三个属性；
        （3）监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些其他事情。


1.  * computed 计算属性是基于它们的响应式依赖进行缓存的

    * 每当触发重新渲染时，调用方法watch将总会再次执行函数

2.  响应式依赖：
    1. 响应式是在data中声明过的属性
    2. 依赖是指deps数组项，deps数组是vue运行时动态修改的

## 1. computed
    
    computed 虽然写法上像个函数，但是实际上是计算属性。它会根据data数据的数据对象做计算处理，就类似于getter跟setter一样创造一个存取器属性。
    它有个特点：就是Vue内部做了缓存处理，只有它的依赖属性发生了变化，它才会重新计算并且触发渲染，否则不会再次触发计算

    computed默认有缓存效果，当计算属性没有发生变化时，不会重新计算更不会重新渲染。

## 2. watch

    watch观察，在Vue中它是一个侦听器，会对依赖属性进行侦听（观察）。当侦听的属性发生变化时，就会执行一个函数。
    watch是异步函数，如果我们的属性需要在侦听后再执行某个变化，可以使用$nextTick这个API

*   属性值的不同影响watch结果
    1. 当属性值为简单数据类型时，以vm.a为例，由于此时属性值是简单数据类型，所以很容易监听到其发生变化。此时属性值！==改变后的属性值，就会触发watch
    2. 当属性值为复杂数据类型时，以vm.b为例，它保存了{c:2}这个值

    如果它的内存地址发生变化，也就是说原先的{c:2}和后面设置的{c:2}的内存地址不一致，所以就会触发b变了

*   结论：
    当监听属性的属性值为简单数据类型，就互相比较值，值不一样就会触发watch
    如果监听的属性的属性值是复杂数据类型，就比较地址，地址不一样就触发watch
    
*   deep 和 immediate
    1. deep表示深侦听，也就是我设置的属性对应的属性值即使是复杂数据类型，加上deep，就全方位侦听，包括地址、内层属性的地址、内层属性的属性值。
    2. immediate是表示当侦听开始时就先触发callback函数，默认为一开始不会触发watch效果，而仅仅是侦听。

## 两者的应用场景

    当我们试图通过数据对象来创造另一个属性时，推荐使用 computed
    当我们试图通过侦听数据对象的改变来做点什么（比如执行一个函数），我们就可以使用watch，在使用watch时尤其要注意其为异步执行的特点

# 三、Vue的生命周期

*   beforeCreate：是new Vue()之后触发的一个钩子，在当前阶段data、watch、computed以及methods上的数据和方法都不能被访问

*   Created：在实例创建完后发生，在当前阶段已经完成了对数据观测，也就是说可以使用数据，更改数据，在这里更改数据不会触发updated函数。
    可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非想要，可以通过vm.nextTick来访问

*   beforeMount：发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated

*   mountd：在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问Dom节点，使用$refs属性对Dom进行操作

*   beforeUpdate：发生在更新之前，也就是响应数据发生更新，虚拟dom重新渲染之前被触发，可以在当前阶段进行更改数据，不会造成重渲染

*   updated：发生在更新完成之后，当前阶段组件Dom已完成更新。注意的是避免在此期间更改数据，因为这可能导致无限的循环的更新

*   beforeDestroy：发生在实例销毁之前，在当前阶段完全可以被使用，我们可以在这时进行善后收尾工作，比如清除定时器

*   destroyed：发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸载，监听被移出，子实例也统统被销毁

# 四、为什么组件的data必须是一个函数

    一个组件可能在很多地方使用，也就是会创建很多个实例，如果data是一个对象的话，对象是引用类型，一个实例修改data会影响到其他实例，
    所以data必须使用函数，为每一个实例创建一个属于自己的data，使其同一个组件的不同实例互不影响

# 五、组件之间怎么通信

## 1. 父子组件通信

    父组件->子组件：prop
    子组件->父组件：$on / $emit
    获取组件实例：使用 $parent / $children，$refs.xxx，获取到实例后直接获取属性数据或调用组件方法

## 2. 兄弟组件通信

    Event Bus：每一个实例都是Event Bus，都支持 $on / $emit，可以为兄弟组件的实例之间new一个Vue实例，作为Event Bus进行通信
    但一个弊端就是，这种方式并不会自动销毁，所以为了避免回调函数重复执行，还要在 onUnmounted 中去移除回调函数。

    Vuex：将状态和方法提取到Vuex，完成共享

## 3. 跨级组件通信

    使用 provide/inject

    Event Bus：同兄弟组件Event Bus通信

    Vuex：将状态和方法提取到Vuex，完成共享

## 4. Vue事件绑定原理

    每一个Vue实例都是一个Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有 $on 方法将事件注册到内部，在需要的时候使用 $emit 触发函数，
    而对于原生 native 事件，使用 addEventListener 绑定到真实的 DOM 元素

# 六、slot是什么？有什么用？原理是什么？

*   slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。
    插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。
    slot又分三类，默认插槽，具名插槽和作用域插槽。

*   默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。

*   具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。

*   作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，
    可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。

*   实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，
    当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。

# 七、Vue模板渲染的原理是什么？

*   Vue 中的模板template无法被浏览器解析和渲染，因为这不属于浏览器的标准，不是正确的HTML语法，
    所以需要将template转换为一个JavaScript函数，这样浏览器就可以执行这个函数并渲染出对应的HTML元素，就可以让视图跑起来，这一个转换的过程，就成为模板编译

*   模板编译又分为三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render

    1. parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转换为抽象语法树 AST
    2. optimize阶段：遍历 AST，找到其中一些静态节点并进行标记，方便在页面渲染的时候进行diff比较时，直接跳过这一些静态节点，优化 runtime 的性能
    3. generate阶段：将最终的AST转换为render函数字符串

# 八、template预编译是什么？

*   对于Vue组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后再也不会进行编译。
    因此，编译对组件的runtime是一种性能损耗

*   而模板编译的目的仅仅是奖template转化为render function，这个过程，正好可以在项目构建的过程中完成，
    这样可以让实际组件在runtime时直接跳过模板，进而提升性能，这个在项目构建的编译template的过程，就是预编译

# 九、那template和jsx的有什么分别？

*   对于runtime来说，只需要保证组件存在render函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成render函数就可以

*   在webpack中，我们使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在webpack构建过程中，将template预编译成render函数

*   与react类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数

*   所以template和jsx都是render的一种表现形式，不同的是：

    jsx相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而template虽然显得呆滞，但是template在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护

# 十、Vue和React区别

## 1. 监听数据变化的实现原理不同

1. Vue通过getter/setter以及一些函数的劫持，能够准确知道数据变化，不需要特别的优化就能够达到很好的性能
2. React默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量的不必要VDOM的重新渲染

    为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变。
    所以应该说没有好坏之分，Vue更加简单，而React构建大型应用的时候更加棒。

    因为一般都会用一个数据层的框架比如 Vuex 和 Redux。

## 2. 数据流的不同

    Vue中默认是支持双向绑定的。在Vue1.0中我们可以实现两种双向绑定：

        父子组件之间，props 可以双向绑定

        组件与DOM之间可以通过 v-model 双向绑定

    在 Vue2.x 中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且 Vue2.x 已经不鼓励组件对自己的 props 进行任何修改了。
    所以现在我们只有 组件 <--> DOM 之间的双向绑定这一种。

    然而 React 从诞生之初就不支持双向绑定，React一直提倡的是单向数据流，他称之为 onChange/setState()模式。
    不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。

## 3. 模板渲染方式不同

    在表层上， 模板的语法不同

        React 是通过JSX渲染模板
        而Vue是通过一种拓展的HTML语法进行渲染

    但其实这只是表面现象，毕竟React并不必须依赖JSX。
    在深层上，模板的原理不同，这才是他们的本质区别：

    React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的
    
    Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现

    对这一点，我个人比较喜欢React的做法，因为他更加纯粹更加原生，而Vue的做法显得有些独特，会把HTML弄得很乱。
    举个例子，说明React的好处：
        react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。
        但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。

## 4. Vuex和Redux的区别

### Vuex
  
*  Vuex是一个专为Vue开发的应用程序的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
1. Vuex的状态存储是响应式的
2. 不能直接修改Vuex的状态

### 
    从表面上来说，store 注入和使用方式有一些区别。
    在 Vuex 中，$store 被直接注入到了组件实例中，因此可以比较灵活的使用：

        使用 dispatch 和 commit 提交更新
        通过 mapState 或者直接通过 this.$store 来读取数据

    在 Redux 中，我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。
    另外 Vuex 更加灵活一些，组件中既可以 dispatch action 也可以 commit updates，而 Redux 中只能进行 dispatch，并不能直接调用 reducer 进行修改。

    从实现原理上来说，最大的区别是两点：
        Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改

        Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的（如果看Vuex源码会知道，其实他内部直接创建一个Vue实例用来跟踪数据变化）

    而这两点的区别，其实也是因为 React 和 Vue的设计理念上的区别。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用 Vue 的感觉。

# 十一、什么是Virtual Dom

    Virtual Dom是Dom节点在JavaScript中的一种抽象数据结构，之所以需要虚拟DOM，是因为浏览器中操作DOM的代价比较昂贵，频繁操作DOM会产生性能问题。
    虚拟DOM的作用是在每一次响应式数据发生变化引发重渲染时，Vue对比更新前后的虚拟DOM，匹配找出更可能少的需要更新的真实DOM，从而提升性能

# 十二、Vue中的Diff算法

*   在新老虚拟Dom对比时
    1. 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换
    2. 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况（如果新的children没有子节点，将旧的子节点移除）
    3. 比较如果都有子节点，则进行updateChildren，判断如果对这些新老节点进行操作（diff核心）
    4. 匹配时，找到相同的子节点，递归比较子节点

*   在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂度O(n^3)降低值O(n)，
    也就是说，只有当新旧chilren都为多个子节点时才需要用核心的Diff算法进行同层级比较

# 十三、key属性的作用是什么

    在对节点进行diff的过程中，判断是否为相同节点的一个很重要的条件就是key是否相等

    如果是相同节点，则会尽可能的复用原有的DOM节点

    所以key属性是提供给框架在diff的时候使用

# 十四、Vue2.0 和 Vue3.0的区别

## 1. 重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：

1. 可直接监听数组类型的数据变化
2. 监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升
3. 拦截方法较多，可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行
4. 直接实现对象属性的删除/新增
5. 返回值为对象实例，而object.property只能遍历对象属性直接修改

## 2. 新增Composition API，更好的逻辑复用和代码组织

## 3. 重构Virtual Dom

1. 模板编译时的优化，将一些静态节点编译成常量
2. slot优化，将slot编译为lazy函数，将 slot 的渲染决定权给子组件
3. 模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）

## 4. 代码结构调整，更便于Tree shaking，使得体积更小
## 5. 使用Typescript替换Flow

# 十五、为什么要新增Composition API，它能解决什么问题

*   Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。

*   另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行。

*   所以Composition API的出现，主要是也是为了解决Option API带来的问题，第一个是代码组织问题，Compostion API可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。

*   第二个是实现代码的逻辑提取与复用，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。

# 十六、Compositon API和React Hook很像，说说区别

*   从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制

    1.  不能在循环、条件、嵌套函数中调用Hook
    2.  必须确保总是在你的React函数的顶层调用Hook
    3.  useEffect、useMemo等函数必须手动确定依赖关系

*   而Composition API是基于Vue的响应式系统实现的，与React Hook的相比

    1.  声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢
    2.  Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用
    3.  响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。

# 十七、SSR是什么？原理是什么？

*   在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，
    这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染SSR。

*   而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。
    除了数据意外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，
    这个将数据和HTML同步的过程，又叫做客户端激活。

*   使用SSR的优点：

    1. 有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。
        * 低级爬虫：只请求URL，URL返回的HTML是什么内容就爬什么内容。
        * 高级爬虫：请求URL，加载并执行JavaScript脚本渲染页面，爬JavaScript渲染后的内容。

    2. 白屏时间更短：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。

*   SSR（server side render）：服务端渲染就是在浏览器请求页面URL的时候，服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中。这个服务端组装HTML的过程，叫做服务端渲染


# 十八、发布订阅模式

    发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
    优点：为时间是解耦，为对象之间解构。
    在异步编程中帮助解耦

# 十九、单例模式

    单例设计模式：保证一个类仅有一个实例，并且提供一个访问它的全局访问点。有些对象只需要一个，这时可用单例模式。
    单例模式的核心是确保只有一个实例，并提供全局访问
    在JavaScript可以通过直接创建一个对象来实现单例模式
    可以用闭包的方式实现私有变量

# 二十、Vue-router原理

## vue-router有几种模式？
*   三种模式，"hash" | "history" | "abstract"，其中浏览器环境默认为hash，Node.js 环境默认为abstract

    hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History API 的浏览器。
    history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。
    abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。

## 基本原理
    $router的 push 和 replace 是手动调用内部路径切换方法 transitionTo，go，back，forward 方法实际调用的是window.history.go()，以及浏览器的前进后退会触发相应的监听事件，然后调用transitionTo，之后更新路由，触发<router-view>的重新渲染

1. hash模式是优先监听popstate事件,不行就降级为hashchange事件，history模式监听popstate事件；
2. history.pushState()和history.replaceState()修改浏览器历史栈后url改变但不会刷新页面，不会触发popstate事件；
3. window.location.hash = '#/b' 修改hash不会刷新页面，会触发hashchange事件，hash的改变会自动添加到浏览器历史记录中；

## 执行流程
1. 点击 router-link或执行$router.push()

2. 调用this.history.push，不同模式下该函数的实现略有不同，以下以hash模式为例，

3. 先执行 this.transitionTo 做路径切换，在切换完成的回调函数中，执行 pushHash 函数；

    * pushHash 优先用pushState ，不行就降级为window.location.hash = path
    * pushState 会调用浏览器原生的 history 的 pushState 接口或者 replaceState 接口，更新浏览器的 url 地址，并把当前 url 压入历史栈中。

4. updateRoute ，更新 this.apps 保存的组件实例的 _route 值

5. 重新渲染组件

    通过Vue.mixin()方法，全局注册一个混合，影响注册之后所有创建的每个Vue实例，该混合在beforeCreate钩子中通过Vue.util.defineReactive()定义了响应式的_route属性。所谓响应式属性，即当_route值改变时，会自动调用Vue实例的render()方法，更新视图。

# 二十一、Vuex 和 localStorage 的区别

## 1. 区别
1. vuex存储在内存中
2. localStorage则以文件的方式存储在本地，localStorage只能存储
* localStorage只能存储字符串类型的数据，存储对象需要JSON的stringfy和parse方法进行处理。读取内存比读取硬盘速度要快

## 2. 应用场景
* Vuex是一个转为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预见的方式发生变化。Vuex用于组件之间的传值

* localStorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用

* vuex能做到数据的响应式，localStorage不能

## 3. 永久性
    刷新页面时vuex存储的值会丢失，localStorage不会

# 二十二、Vue双向绑定原理

## 1. 原理
*   View 的变化能实时让Model发生变化，而Model的变化也能实时更新到View

*   Vue采用数据劫持&发布-订阅模式的方法，通过ES5提供的Object.defineProperty()方法来劫持（监控）各属性的getter、setter，并在数据（对象）发生变动时通知订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。

*   要实现Vue中的双向数据绑定，大致可以划分为三个模块：Observer、Compile、Watcher

1. Observer 数据监听器
    负责对数据对象的所有属性进行监听（数据劫持），监听到数据发生变化后通知订阅者

2. Comiler 指令解析器
    扫描模板，并对指令进行解析，然后绑定指定事件

3. Watcher 订阅者
    关联Observer和compile能够订阅并收到属性变化的通知，执行指令绑定的相应操作，更新视图。
    Updata()是它自身的一个方法，用于Compile中绑定的回调，更新视图
    
# 二十三、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？

## 1. 实现方式
1. param方式
    1. 配置路由格式:/router/:id
    2. 传递的方式:在path后面跟上对应的值
    3. 传递后形成的路径:/router/123

2. query方式
    1. 配置路由格式:/router，也就是普通配置
    2. 传递的方式:对象中使用query的key作为传递方式
    3. 传递后形成的路径:/router?id=123